// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rockbox/v1alpha1/playback.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Rockbox_V1alpha1_PlayRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var elapsed: Int64 = 0

  var offset: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayOrPauseRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayOrPauseResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PauseRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PauseResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_ResumeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_ResumeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_NextRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_NextResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PreviousRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PreviousResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_FastForwardRewindRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var newTime: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_FastForwardRewindResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_StatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_StreamStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_StatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_CurrentTrackRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_CurrentTrackResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var artist: String {
    get {return _storage._artist}
    set {_uniqueStorage()._artist = newValue}
  }

  var album: String {
    get {return _storage._album}
    set {_uniqueStorage()._album = newValue}
  }

  var genre: String {
    get {return _storage._genre}
    set {_uniqueStorage()._genre = newValue}
  }

  var disc: String {
    get {return _storage._disc}
    set {_uniqueStorage()._disc = newValue}
  }

  var trackString: String {
    get {return _storage._trackString}
    set {_uniqueStorage()._trackString = newValue}
  }

  var yearString: String {
    get {return _storage._yearString}
    set {_uniqueStorage()._yearString = newValue}
  }

  var composer: String {
    get {return _storage._composer}
    set {_uniqueStorage()._composer = newValue}
  }

  var comment: String {
    get {return _storage._comment}
    set {_uniqueStorage()._comment = newValue}
  }

  var albumArtist: String {
    get {return _storage._albumArtist}
    set {_uniqueStorage()._albumArtist = newValue}
  }

  var grouping: String {
    get {return _storage._grouping}
    set {_uniqueStorage()._grouping = newValue}
  }

  var discnum: Int32 {
    get {return _storage._discnum}
    set {_uniqueStorage()._discnum = newValue}
  }

  var tracknum: Int32 {
    get {return _storage._tracknum}
    set {_uniqueStorage()._tracknum = newValue}
  }

  var layer: Int32 {
    get {return _storage._layer}
    set {_uniqueStorage()._layer = newValue}
  }

  var year: Int32 {
    get {return _storage._year}
    set {_uniqueStorage()._year = newValue}
  }

  var bitrate: UInt32 {
    get {return _storage._bitrate}
    set {_uniqueStorage()._bitrate = newValue}
  }

  var frequency: UInt64 {
    get {return _storage._frequency}
    set {_uniqueStorage()._frequency = newValue}
  }

  var filesize: UInt64 {
    get {return _storage._filesize}
    set {_uniqueStorage()._filesize = newValue}
  }

  var length: UInt64 {
    get {return _storage._length}
    set {_uniqueStorage()._length = newValue}
  }

  var elapsed: UInt64 {
    get {return _storage._elapsed}
    set {_uniqueStorage()._elapsed = newValue}
  }

  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  var albumArt: String {
    get {return _storage._albumArt ?? String()}
    set {_uniqueStorage()._albumArt = newValue}
  }
  /// Returns true if `albumArt` has been explicitly set.
  var hasAlbumArt: Bool {return _storage._albumArt != nil}
  /// Clears the value of `albumArt`. Subsequent reads from it will return its default value.
  mutating func clearAlbumArt() {_uniqueStorage()._albumArt = nil}

  var albumID: String {
    get {return _storage._albumID}
    set {_uniqueStorage()._albumID = newValue}
  }

  var artistID: String {
    get {return _storage._artistID}
    set {_uniqueStorage()._artistID = newValue}
  }

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Rockbox_V1alpha1_StreamCurrentTrackRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_NextTrackRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_NextTrackResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var artist: String {
    get {return _storage._artist}
    set {_uniqueStorage()._artist = newValue}
  }

  var album: String {
    get {return _storage._album}
    set {_uniqueStorage()._album = newValue}
  }

  var genre: String {
    get {return _storage._genre}
    set {_uniqueStorage()._genre = newValue}
  }

  var disc: String {
    get {return _storage._disc}
    set {_uniqueStorage()._disc = newValue}
  }

  var trackString: String {
    get {return _storage._trackString}
    set {_uniqueStorage()._trackString = newValue}
  }

  var yearString: String {
    get {return _storage._yearString}
    set {_uniqueStorage()._yearString = newValue}
  }

  var composer: String {
    get {return _storage._composer}
    set {_uniqueStorage()._composer = newValue}
  }

  var comment: String {
    get {return _storage._comment}
    set {_uniqueStorage()._comment = newValue}
  }

  var albumArtist: String {
    get {return _storage._albumArtist}
    set {_uniqueStorage()._albumArtist = newValue}
  }

  var grouping: String {
    get {return _storage._grouping}
    set {_uniqueStorage()._grouping = newValue}
  }

  var discnum: Int32 {
    get {return _storage._discnum}
    set {_uniqueStorage()._discnum = newValue}
  }

  var tracknum: Int32 {
    get {return _storage._tracknum}
    set {_uniqueStorage()._tracknum = newValue}
  }

  var layer: Int32 {
    get {return _storage._layer}
    set {_uniqueStorage()._layer = newValue}
  }

  var year: Int32 {
    get {return _storage._year}
    set {_uniqueStorage()._year = newValue}
  }

  var bitrate: UInt32 {
    get {return _storage._bitrate}
    set {_uniqueStorage()._bitrate = newValue}
  }

  var frequency: UInt64 {
    get {return _storage._frequency}
    set {_uniqueStorage()._frequency = newValue}
  }

  var filesize: UInt64 {
    get {return _storage._filesize}
    set {_uniqueStorage()._filesize = newValue}
  }

  var length: UInt64 {
    get {return _storage._length}
    set {_uniqueStorage()._length = newValue}
  }

  var elapsed: UInt64 {
    get {return _storage._elapsed}
    set {_uniqueStorage()._elapsed = newValue}
  }

  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Rockbox_V1alpha1_FlushAndReloadTracksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_FlushAndReloadTracksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetFilePositionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetFilePositionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var position: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_HardStopRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_HardStopResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayAlbumRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var albumID: String = String()

  var shuffle: Bool {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }
  /// Returns true if `shuffle` has been explicitly set.
  var hasShuffle: Bool {return self._shuffle != nil}
  /// Clears the value of `shuffle`. Subsequent reads from it will return its default value.
  mutating func clearShuffle() {self._shuffle = nil}

  var position: Int32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shuffle: Bool? = nil
  fileprivate var _position: Int32? = nil
}

struct Rockbox_V1alpha1_PlayAlbumResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayArtistTracksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var artistID: String = String()

  var shuffle: Bool {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }
  /// Returns true if `shuffle` has been explicitly set.
  var hasShuffle: Bool {return self._shuffle != nil}
  /// Clears the value of `shuffle`. Subsequent reads from it will return its default value.
  mutating func clearShuffle() {self._shuffle = nil}

  var position: Int32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shuffle: Bool? = nil
  fileprivate var _position: Int32? = nil
}

struct Rockbox_V1alpha1_PlayArtistTracksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayPlaylistRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var playlistID: String = String()

  var shuffle: Bool {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }
  /// Returns true if `shuffle` has been explicitly set.
  var hasShuffle: Bool {return self._shuffle != nil}
  /// Clears the value of `shuffle`. Subsequent reads from it will return its default value.
  mutating func clearShuffle() {self._shuffle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shuffle: Bool? = nil
}

struct Rockbox_V1alpha1_PlayPlaylistResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayDirectoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var shuffle: Bool {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }
  /// Returns true if `shuffle` has been explicitly set.
  var hasShuffle: Bool {return self._shuffle != nil}
  /// Clears the value of `shuffle`. Subsequent reads from it will return its default value.
  mutating func clearShuffle() {self._shuffle = nil}

  var recurse: Bool {
    get {return _recurse ?? false}
    set {_recurse = newValue}
  }
  /// Returns true if `recurse` has been explicitly set.
  var hasRecurse: Bool {return self._recurse != nil}
  /// Clears the value of `recurse`. Subsequent reads from it will return its default value.
  mutating func clearRecurse() {self._recurse = nil}

  var position: Int32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shuffle: Bool? = nil
  fileprivate var _recurse: Bool? = nil
  fileprivate var _position: Int32? = nil
}

struct Rockbox_V1alpha1_PlayMusicDirectoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shuffle: Bool {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }
  /// Returns true if `shuffle` has been explicitly set.
  var hasShuffle: Bool {return self._shuffle != nil}
  /// Clears the value of `shuffle`. Subsequent reads from it will return its default value.
  mutating func clearShuffle() {self._shuffle = nil}

  var recurse: Bool {
    get {return _recurse ?? false}
    set {_recurse = newValue}
  }
  /// Returns true if `recurse` has been explicitly set.
  var hasRecurse: Bool {return self._recurse != nil}
  /// Clears the value of `recurse`. Subsequent reads from it will return its default value.
  mutating func clearRecurse() {self._recurse = nil}

  var position: Int32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shuffle: Bool? = nil
  fileprivate var _recurse: Bool? = nil
  fileprivate var _position: Int32? = nil
}

struct Rockbox_V1alpha1_PlayDirectoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayMusicDirectoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayTrackRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayTrackResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayLikedTracksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shuffle: Bool {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }
  /// Returns true if `shuffle` has been explicitly set.
  var hasShuffle: Bool {return self._shuffle != nil}
  /// Clears the value of `shuffle`. Subsequent reads from it will return its default value.
  mutating func clearShuffle() {self._shuffle = nil}

  var position: Int32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shuffle: Bool? = nil
  fileprivate var _position: Int32? = nil
}

struct Rockbox_V1alpha1_PlayLikedTracksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlayAllTracksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var shuffle: Bool {
    get {return _shuffle ?? false}
    set {_shuffle = newValue}
  }
  /// Returns true if `shuffle` has been explicitly set.
  var hasShuffle: Bool {return self._shuffle != nil}
  /// Clears the value of `shuffle`. Subsequent reads from it will return its default value.
  mutating func clearShuffle() {self._shuffle = nil}

  var position: Int32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _shuffle: Bool? = nil
  fileprivate var _position: Int32? = nil
}

struct Rockbox_V1alpha1_PlayAllTracksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_StreamPlaylistRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_PlaylistResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: Int32 = 0

  var amount: Int32 = 0

  var tracks: [Rockbox_V1alpha1_CurrentTrackResponse] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rockbox.v1alpha1"

extension Rockbox_V1alpha1_PlayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}elapsed\0\u{1}offset\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.elapsed) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.elapsed != 0 {
      try visitor.visitSingularInt64Field(value: self.elapsed, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayRequest, rhs: Rockbox_V1alpha1_PlayRequest) -> Bool {
    if lhs.elapsed != rhs.elapsed {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayResponse, rhs: Rockbox_V1alpha1_PlayResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayOrPauseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayOrPauseRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayOrPauseRequest, rhs: Rockbox_V1alpha1_PlayOrPauseRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayOrPauseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayOrPauseResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayOrPauseResponse, rhs: Rockbox_V1alpha1_PlayOrPauseResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PauseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PauseRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PauseRequest, rhs: Rockbox_V1alpha1_PauseRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PauseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PauseResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PauseResponse, rhs: Rockbox_V1alpha1_PauseResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_ResumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResumeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_ResumeRequest, rhs: Rockbox_V1alpha1_ResumeRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_ResumeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResumeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_ResumeResponse, rhs: Rockbox_V1alpha1_ResumeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_NextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_NextRequest, rhs: Rockbox_V1alpha1_NextRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_NextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_NextResponse, rhs: Rockbox_V1alpha1_NextResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PreviousRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreviousRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PreviousRequest, rhs: Rockbox_V1alpha1_PreviousRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PreviousResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PreviousResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PreviousResponse, rhs: Rockbox_V1alpha1_PreviousResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_FastForwardRewindRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FastForwardRewindRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}new_time\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.newTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.newTime != 0 {
      try visitor.visitSingularInt32Field(value: self.newTime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_FastForwardRewindRequest, rhs: Rockbox_V1alpha1_FastForwardRewindRequest) -> Bool {
    if lhs.newTime != rhs.newTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_FastForwardRewindResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FastForwardRewindResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_FastForwardRewindResponse, rhs: Rockbox_V1alpha1_FastForwardRewindResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_StatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_StatusRequest, rhs: Rockbox_V1alpha1_StatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_StreamStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamStatusRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_StreamStatusRequest, rhs: Rockbox_V1alpha1_StreamStatusRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_StatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatusResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_StatusResponse, rhs: Rockbox_V1alpha1_StatusResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_CurrentTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CurrentTrackRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_CurrentTrackRequest, rhs: Rockbox_V1alpha1_CurrentTrackRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_CurrentTrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CurrentTrackResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}title\0\u{1}artist\0\u{1}album\0\u{1}genre\0\u{1}disc\0\u{3}track_string\0\u{3}year_string\0\u{1}composer\0\u{1}comment\0\u{3}album_artist\0\u{1}grouping\0\u{1}discnum\0\u{1}tracknum\0\u{1}layer\0\u{1}year\0\u{1}bitrate\0\u{1}frequency\0\u{1}filesize\0\u{1}length\0\u{1}elapsed\0\u{1}path\0\u{3}album_art\0\u{3}album_id\0\u{3}artist_id\0\u{1}id\0")

  fileprivate class _StorageClass {
    var _title: String = String()
    var _artist: String = String()
    var _album: String = String()
    var _genre: String = String()
    var _disc: String = String()
    var _trackString: String = String()
    var _yearString: String = String()
    var _composer: String = String()
    var _comment: String = String()
    var _albumArtist: String = String()
    var _grouping: String = String()
    var _discnum: Int32 = 0
    var _tracknum: Int32 = 0
    var _layer: Int32 = 0
    var _year: Int32 = 0
    var _bitrate: UInt32 = 0
    var _frequency: UInt64 = 0
    var _filesize: UInt64 = 0
    var _length: UInt64 = 0
    var _elapsed: UInt64 = 0
    var _path: String = String()
    var _albumArt: String? = nil
    var _albumID: String = String()
    var _artistID: String = String()
    var _id: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _artist = source._artist
      _album = source._album
      _genre = source._genre
      _disc = source._disc
      _trackString = source._trackString
      _yearString = source._yearString
      _composer = source._composer
      _comment = source._comment
      _albumArtist = source._albumArtist
      _grouping = source._grouping
      _discnum = source._discnum
      _tracknum = source._tracknum
      _layer = source._layer
      _year = source._year
      _bitrate = source._bitrate
      _frequency = source._frequency
      _filesize = source._filesize
      _length = source._length
      _elapsed = source._elapsed
      _path = source._path
      _albumArt = source._albumArt
      _albumID = source._albumID
      _artistID = source._artistID
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._artist) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._album) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._genre) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._disc) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._trackString) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._yearString) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._composer) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._comment) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._albumArtist) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._grouping) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._discnum) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._tracknum) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._layer) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._year) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._bitrate) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._frequency) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._filesize) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._length) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._elapsed) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._albumArt) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._albumID) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._artistID) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._artist.isEmpty {
        try visitor.visitSingularStringField(value: _storage._artist, fieldNumber: 2)
      }
      if !_storage._album.isEmpty {
        try visitor.visitSingularStringField(value: _storage._album, fieldNumber: 3)
      }
      if !_storage._genre.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genre, fieldNumber: 4)
      }
      if !_storage._disc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._disc, fieldNumber: 5)
      }
      if !_storage._trackString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._trackString, fieldNumber: 6)
      }
      if !_storage._yearString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._yearString, fieldNumber: 7)
      }
      if !_storage._composer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._composer, fieldNumber: 8)
      }
      if !_storage._comment.isEmpty {
        try visitor.visitSingularStringField(value: _storage._comment, fieldNumber: 9)
      }
      if !_storage._albumArtist.isEmpty {
        try visitor.visitSingularStringField(value: _storage._albumArtist, fieldNumber: 10)
      }
      if !_storage._grouping.isEmpty {
        try visitor.visitSingularStringField(value: _storage._grouping, fieldNumber: 11)
      }
      if _storage._discnum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._discnum, fieldNumber: 12)
      }
      if _storage._tracknum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tracknum, fieldNumber: 13)
      }
      if _storage._layer != 0 {
        try visitor.visitSingularInt32Field(value: _storage._layer, fieldNumber: 14)
      }
      if _storage._year != 0 {
        try visitor.visitSingularInt32Field(value: _storage._year, fieldNumber: 15)
      }
      if _storage._bitrate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bitrate, fieldNumber: 16)
      }
      if _storage._frequency != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._frequency, fieldNumber: 17)
      }
      if _storage._filesize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._filesize, fieldNumber: 18)
      }
      if _storage._length != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._length, fieldNumber: 19)
      }
      if _storage._elapsed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._elapsed, fieldNumber: 20)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 21)
      }
      try { if let v = _storage._albumArt {
        try visitor.visitSingularStringField(value: v, fieldNumber: 22)
      } }()
      if !_storage._albumID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._albumID, fieldNumber: 23)
      }
      if !_storage._artistID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._artistID, fieldNumber: 24)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_CurrentTrackResponse, rhs: Rockbox_V1alpha1_CurrentTrackResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._artist != rhs_storage._artist {return false}
        if _storage._album != rhs_storage._album {return false}
        if _storage._genre != rhs_storage._genre {return false}
        if _storage._disc != rhs_storage._disc {return false}
        if _storage._trackString != rhs_storage._trackString {return false}
        if _storage._yearString != rhs_storage._yearString {return false}
        if _storage._composer != rhs_storage._composer {return false}
        if _storage._comment != rhs_storage._comment {return false}
        if _storage._albumArtist != rhs_storage._albumArtist {return false}
        if _storage._grouping != rhs_storage._grouping {return false}
        if _storage._discnum != rhs_storage._discnum {return false}
        if _storage._tracknum != rhs_storage._tracknum {return false}
        if _storage._layer != rhs_storage._layer {return false}
        if _storage._year != rhs_storage._year {return false}
        if _storage._bitrate != rhs_storage._bitrate {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._filesize != rhs_storage._filesize {return false}
        if _storage._length != rhs_storage._length {return false}
        if _storage._elapsed != rhs_storage._elapsed {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._albumArt != rhs_storage._albumArt {return false}
        if _storage._albumID != rhs_storage._albumID {return false}
        if _storage._artistID != rhs_storage._artistID {return false}
        if _storage._id != rhs_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_StreamCurrentTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamCurrentTrackRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_StreamCurrentTrackRequest, rhs: Rockbox_V1alpha1_StreamCurrentTrackRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_NextTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextTrackRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_NextTrackRequest, rhs: Rockbox_V1alpha1_NextTrackRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_NextTrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextTrackResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}title\0\u{1}artist\0\u{1}album\0\u{1}genre\0\u{1}disc\0\u{3}track_string\0\u{3}year_string\0\u{1}composer\0\u{1}comment\0\u{3}album_artist\0\u{1}grouping\0\u{1}discnum\0\u{1}tracknum\0\u{1}layer\0\u{1}year\0\u{1}bitrate\0\u{1}frequency\0\u{1}filesize\0\u{1}length\0\u{1}elapsed\0\u{1}path\0")

  fileprivate class _StorageClass {
    var _title: String = String()
    var _artist: String = String()
    var _album: String = String()
    var _genre: String = String()
    var _disc: String = String()
    var _trackString: String = String()
    var _yearString: String = String()
    var _composer: String = String()
    var _comment: String = String()
    var _albumArtist: String = String()
    var _grouping: String = String()
    var _discnum: Int32 = 0
    var _tracknum: Int32 = 0
    var _layer: Int32 = 0
    var _year: Int32 = 0
    var _bitrate: UInt32 = 0
    var _frequency: UInt64 = 0
    var _filesize: UInt64 = 0
    var _length: UInt64 = 0
    var _elapsed: UInt64 = 0
    var _path: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _artist = source._artist
      _album = source._album
      _genre = source._genre
      _disc = source._disc
      _trackString = source._trackString
      _yearString = source._yearString
      _composer = source._composer
      _comment = source._comment
      _albumArtist = source._albumArtist
      _grouping = source._grouping
      _discnum = source._discnum
      _tracknum = source._tracknum
      _layer = source._layer
      _year = source._year
      _bitrate = source._bitrate
      _frequency = source._frequency
      _filesize = source._filesize
      _length = source._length
      _elapsed = source._elapsed
      _path = source._path
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._artist) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._album) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._genre) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._disc) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._trackString) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._yearString) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._composer) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._comment) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._albumArtist) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._grouping) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._discnum) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._tracknum) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._layer) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._year) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._bitrate) }()
        case 17: try { try decoder.decodeSingularUInt64Field(value: &_storage._frequency) }()
        case 18: try { try decoder.decodeSingularUInt64Field(value: &_storage._filesize) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._length) }()
        case 20: try { try decoder.decodeSingularUInt64Field(value: &_storage._elapsed) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._artist.isEmpty {
        try visitor.visitSingularStringField(value: _storage._artist, fieldNumber: 2)
      }
      if !_storage._album.isEmpty {
        try visitor.visitSingularStringField(value: _storage._album, fieldNumber: 3)
      }
      if !_storage._genre.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genre, fieldNumber: 4)
      }
      if !_storage._disc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._disc, fieldNumber: 5)
      }
      if !_storage._trackString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._trackString, fieldNumber: 6)
      }
      if !_storage._yearString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._yearString, fieldNumber: 7)
      }
      if !_storage._composer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._composer, fieldNumber: 8)
      }
      if !_storage._comment.isEmpty {
        try visitor.visitSingularStringField(value: _storage._comment, fieldNumber: 9)
      }
      if !_storage._albumArtist.isEmpty {
        try visitor.visitSingularStringField(value: _storage._albumArtist, fieldNumber: 10)
      }
      if !_storage._grouping.isEmpty {
        try visitor.visitSingularStringField(value: _storage._grouping, fieldNumber: 11)
      }
      if _storage._discnum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._discnum, fieldNumber: 12)
      }
      if _storage._tracknum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._tracknum, fieldNumber: 13)
      }
      if _storage._layer != 0 {
        try visitor.visitSingularInt32Field(value: _storage._layer, fieldNumber: 14)
      }
      if _storage._year != 0 {
        try visitor.visitSingularInt32Field(value: _storage._year, fieldNumber: 15)
      }
      if _storage._bitrate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bitrate, fieldNumber: 16)
      }
      if _storage._frequency != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._frequency, fieldNumber: 17)
      }
      if _storage._filesize != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._filesize, fieldNumber: 18)
      }
      if _storage._length != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._length, fieldNumber: 19)
      }
      if _storage._elapsed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._elapsed, fieldNumber: 20)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_NextTrackResponse, rhs: Rockbox_V1alpha1_NextTrackResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._title != rhs_storage._title {return false}
        if _storage._artist != rhs_storage._artist {return false}
        if _storage._album != rhs_storage._album {return false}
        if _storage._genre != rhs_storage._genre {return false}
        if _storage._disc != rhs_storage._disc {return false}
        if _storage._trackString != rhs_storage._trackString {return false}
        if _storage._yearString != rhs_storage._yearString {return false}
        if _storage._composer != rhs_storage._composer {return false}
        if _storage._comment != rhs_storage._comment {return false}
        if _storage._albumArtist != rhs_storage._albumArtist {return false}
        if _storage._grouping != rhs_storage._grouping {return false}
        if _storage._discnum != rhs_storage._discnum {return false}
        if _storage._tracknum != rhs_storage._tracknum {return false}
        if _storage._layer != rhs_storage._layer {return false}
        if _storage._year != rhs_storage._year {return false}
        if _storage._bitrate != rhs_storage._bitrate {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._filesize != rhs_storage._filesize {return false}
        if _storage._length != rhs_storage._length {return false}
        if _storage._elapsed != rhs_storage._elapsed {return false}
        if _storage._path != rhs_storage._path {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_FlushAndReloadTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlushAndReloadTracksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_FlushAndReloadTracksRequest, rhs: Rockbox_V1alpha1_FlushAndReloadTracksRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_FlushAndReloadTracksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlushAndReloadTracksResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_FlushAndReloadTracksResponse, rhs: Rockbox_V1alpha1_FlushAndReloadTracksResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetFilePositionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFilePositionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetFilePositionRequest, rhs: Rockbox_V1alpha1_GetFilePositionRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetFilePositionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetFilePositionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}position\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.position != 0 {
      try visitor.visitSingularInt32Field(value: self.position, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetFilePositionResponse, rhs: Rockbox_V1alpha1_GetFilePositionResponse) -> Bool {
    if lhs.position != rhs.position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_HardStopRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HardStopRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_HardStopRequest, rhs: Rockbox_V1alpha1_HardStopRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_HardStopResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HardStopResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_HardStopResponse, rhs: Rockbox_V1alpha1_HardStopResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayAlbumRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayAlbumRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}album_id\0\u{1}shuffle\0\u{1}position\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.albumID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._shuffle) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.albumID.isEmpty {
      try visitor.visitSingularStringField(value: self.albumID, fieldNumber: 1)
    }
    try { if let v = self._shuffle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayAlbumRequest, rhs: Rockbox_V1alpha1_PlayAlbumRequest) -> Bool {
    if lhs.albumID != rhs.albumID {return false}
    if lhs._shuffle != rhs._shuffle {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayAlbumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayAlbumResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayAlbumResponse, rhs: Rockbox_V1alpha1_PlayAlbumResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayArtistTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayArtistTracksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}artist_id\0\u{1}shuffle\0\u{1}position\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artistID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._shuffle) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.artistID.isEmpty {
      try visitor.visitSingularStringField(value: self.artistID, fieldNumber: 1)
    }
    try { if let v = self._shuffle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayArtistTracksRequest, rhs: Rockbox_V1alpha1_PlayArtistTracksRequest) -> Bool {
    if lhs.artistID != rhs.artistID {return false}
    if lhs._shuffle != rhs._shuffle {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayArtistTracksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayArtistTracksResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayArtistTracksResponse, rhs: Rockbox_V1alpha1_PlayArtistTracksResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayPlaylistRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayPlaylistRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}playlist_id\0\u{1}shuffle\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.playlistID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._shuffle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.playlistID.isEmpty {
      try visitor.visitSingularStringField(value: self.playlistID, fieldNumber: 1)
    }
    try { if let v = self._shuffle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayPlaylistRequest, rhs: Rockbox_V1alpha1_PlayPlaylistRequest) -> Bool {
    if lhs.playlistID != rhs.playlistID {return false}
    if lhs._shuffle != rhs._shuffle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayPlaylistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayPlaylistResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayPlaylistResponse, rhs: Rockbox_V1alpha1_PlayPlaylistResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayDirectoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayDirectoryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0\u{1}shuffle\0\u{1}recurse\0\u{1}position\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._shuffle) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._recurse) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try { if let v = self._shuffle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._recurse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayDirectoryRequest, rhs: Rockbox_V1alpha1_PlayDirectoryRequest) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._shuffle != rhs._shuffle {return false}
    if lhs._recurse != rhs._recurse {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayMusicDirectoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayMusicDirectoryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}shuffle\0\u{1}recurse\0\u{1}position\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._shuffle) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._recurse) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shuffle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recurse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayMusicDirectoryRequest, rhs: Rockbox_V1alpha1_PlayMusicDirectoryRequest) -> Bool {
    if lhs._shuffle != rhs._shuffle {return false}
    if lhs._recurse != rhs._recurse {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayDirectoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayDirectoryResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayDirectoryResponse, rhs: Rockbox_V1alpha1_PlayDirectoryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayMusicDirectoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayMusicDirectoryResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayMusicDirectoryResponse, rhs: Rockbox_V1alpha1_PlayMusicDirectoryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayTrackRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayTrackRequest, rhs: Rockbox_V1alpha1_PlayTrackRequest) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayTrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayTrackResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayTrackResponse, rhs: Rockbox_V1alpha1_PlayTrackResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayLikedTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayLikedTracksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}shuffle\0\u{1}position\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._shuffle) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shuffle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayLikedTracksRequest, rhs: Rockbox_V1alpha1_PlayLikedTracksRequest) -> Bool {
    if lhs._shuffle != rhs._shuffle {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayLikedTracksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayLikedTracksResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayLikedTracksResponse, rhs: Rockbox_V1alpha1_PlayLikedTracksResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayAllTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayAllTracksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}shuffle\0\u{1}position\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._shuffle) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shuffle {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._position {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayAllTracksRequest, rhs: Rockbox_V1alpha1_PlayAllTracksRequest) -> Bool {
    if lhs._shuffle != rhs._shuffle {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlayAllTracksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlayAllTracksResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlayAllTracksResponse, rhs: Rockbox_V1alpha1_PlayAllTracksResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_StreamPlaylistRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamPlaylistRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_StreamPlaylistRequest, rhs: Rockbox_V1alpha1_StreamPlaylistRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_PlaylistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PlaylistResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}index\0\u{1}amount\0\u{1}tracks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.amount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt32Field(value: self.index, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt32Field(value: self.amount, fieldNumber: 2)
    }
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_PlaylistResponse, rhs: Rockbox_V1alpha1_PlaylistResponse) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.tracks != rhs.tracks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
