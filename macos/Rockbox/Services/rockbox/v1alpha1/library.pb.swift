// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rockbox/v1alpha1/library.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Rockbox_V1alpha1_Track: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var artist: String {
    get {return _storage._artist}
    set {_uniqueStorage()._artist = newValue}
  }

  var album: String {
    get {return _storage._album}
    set {_uniqueStorage()._album = newValue}
  }

  var albumArtist: String {
    get {return _storage._albumArtist}
    set {_uniqueStorage()._albumArtist = newValue}
  }

  var bitrate: UInt32 {
    get {return _storage._bitrate}
    set {_uniqueStorage()._bitrate = newValue}
  }

  var composer: String {
    get {return _storage._composer}
    set {_uniqueStorage()._composer = newValue}
  }

  var discNumber: UInt32 {
    get {return _storage._discNumber}
    set {_uniqueStorage()._discNumber = newValue}
  }

  var filesize: UInt32 {
    get {return _storage._filesize}
    set {_uniqueStorage()._filesize = newValue}
  }

  var frequency: UInt32 {
    get {return _storage._frequency}
    set {_uniqueStorage()._frequency = newValue}
  }

  var length: UInt32 {
    get {return _storage._length}
    set {_uniqueStorage()._length = newValue}
  }

  var trackNumber: UInt32 {
    get {return _storage._trackNumber}
    set {_uniqueStorage()._trackNumber = newValue}
  }

  var year: UInt32 {
    get {return _storage._year}
    set {_uniqueStorage()._year = newValue}
  }

  var yearString: String {
    get {return _storage._yearString}
    set {_uniqueStorage()._yearString = newValue}
  }

  var genre: String {
    get {return _storage._genre}
    set {_uniqueStorage()._genre = newValue}
  }

  var md5: String {
    get {return _storage._md5}
    set {_uniqueStorage()._md5 = newValue}
  }

  var albumArt: String {
    get {return _storage._albumArt ?? String()}
    set {_uniqueStorage()._albumArt = newValue}
  }
  /// Returns true if `albumArt` has been explicitly set.
  var hasAlbumArt: Bool {return _storage._albumArt != nil}
  /// Clears the value of `albumArt`. Subsequent reads from it will return its default value.
  mutating func clearAlbumArt() {_uniqueStorage()._albumArt = nil}

  var artistID: String {
    get {return _storage._artistID ?? String()}
    set {_uniqueStorage()._artistID = newValue}
  }
  /// Returns true if `artistID` has been explicitly set.
  var hasArtistID: Bool {return _storage._artistID != nil}
  /// Clears the value of `artistID`. Subsequent reads from it will return its default value.
  mutating func clearArtistID() {_uniqueStorage()._artistID = nil}

  var albumID: String {
    get {return _storage._albumID ?? String()}
    set {_uniqueStorage()._albumID = newValue}
  }
  /// Returns true if `albumID` has been explicitly set.
  var hasAlbumID: Bool {return _storage._albumID != nil}
  /// Clears the value of `albumID`. Subsequent reads from it will return its default value.
  mutating func clearAlbumID() {_uniqueStorage()._albumID = nil}

  var genreID: String {
    get {return _storage._genreID ?? String()}
    set {_uniqueStorage()._genreID = newValue}
  }
  /// Returns true if `genreID` has been explicitly set.
  var hasGenreID: Bool {return _storage._genreID != nil}
  /// Clears the value of `genreID`. Subsequent reads from it will return its default value.
  mutating func clearGenreID() {_uniqueStorage()._genreID = nil}

  var createdAt: String {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  var updatedAt: String {
    get {return _storage._updatedAt}
    set {_uniqueStorage()._updatedAt = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Rockbox_V1alpha1_Artist: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var bio: String {
    get {return _bio ?? String()}
    set {_bio = newValue}
  }
  /// Returns true if `bio` has been explicitly set.
  var hasBio: Bool {return self._bio != nil}
  /// Clears the value of `bio`. Subsequent reads from it will return its default value.
  mutating func clearBio() {self._bio = nil}

  var image: String {
    get {return _image ?? String()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {self._image = nil}

  var albums: [Rockbox_V1alpha1_Album] = []

  var tracks: [Rockbox_V1alpha1_Track] = []

  var genres: String {
    get {return _genres ?? String()}
    set {_genres = newValue}
  }
  /// Returns true if `genres` has been explicitly set.
  var hasGenres: Bool {return self._genres != nil}
  /// Clears the value of `genres`. Subsequent reads from it will return its default value.
  mutating func clearGenres() {self._genres = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bio: String? = nil
  fileprivate var _image: String? = nil
  fileprivate var _genres: String? = nil
}

struct Rockbox_V1alpha1_Album: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var title: String = String()

  var artist: String = String()

  var year: UInt32 = 0

  var yearString: String = String()

  var albumArt: String {
    get {return _albumArt ?? String()}
    set {_albumArt = newValue}
  }
  /// Returns true if `albumArt` has been explicitly set.
  var hasAlbumArt: Bool {return self._albumArt != nil}
  /// Clears the value of `albumArt`. Subsequent reads from it will return its default value.
  mutating func clearAlbumArt() {self._albumArt = nil}

  var md5: String = String()

  var artistID: String = String()

  var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  mutating func clearLabel() {self._label = nil}

  var copyrightMessage: String {
    get {return _copyrightMessage ?? String()}
    set {_copyrightMessage = newValue}
  }
  /// Returns true if `copyrightMessage` has been explicitly set.
  var hasCopyrightMessage: Bool {return self._copyrightMessage != nil}
  /// Clears the value of `copyrightMessage`. Subsequent reads from it will return its default value.
  mutating func clearCopyrightMessage() {self._copyrightMessage = nil}

  var tracks: [Rockbox_V1alpha1_Track] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _albumArt: String? = nil
  fileprivate var _label: String? = nil
  fileprivate var _copyrightMessage: String? = nil
}

struct Rockbox_V1alpha1_GetAlbumRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetAlbumResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var album: Rockbox_V1alpha1_Album {
    get {return _album ?? Rockbox_V1alpha1_Album()}
    set {_album = newValue}
  }
  /// Returns true if `album` has been explicitly set.
  var hasAlbum: Bool {return self._album != nil}
  /// Clears the value of `album`. Subsequent reads from it will return its default value.
  mutating func clearAlbum() {self._album = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _album: Rockbox_V1alpha1_Album? = nil
}

struct Rockbox_V1alpha1_GetArtistRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetArtistResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var artist: Rockbox_V1alpha1_Artist {
    get {return _artist ?? Rockbox_V1alpha1_Artist()}
    set {_artist = newValue}
  }
  /// Returns true if `artist` has been explicitly set.
  var hasArtist: Bool {return self._artist != nil}
  /// Clears the value of `artist`. Subsequent reads from it will return its default value.
  mutating func clearArtist() {self._artist = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _artist: Rockbox_V1alpha1_Artist? = nil
}

struct Rockbox_V1alpha1_GetTrackRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetTrackResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var track: Rockbox_V1alpha1_Track {
    get {return _track ?? Rockbox_V1alpha1_Track()}
    set {_track = newValue}
  }
  /// Returns true if `track` has been explicitly set.
  var hasTrack: Bool {return self._track != nil}
  /// Clears the value of `track`. Subsequent reads from it will return its default value.
  mutating func clearTrack() {self._track = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _track: Rockbox_V1alpha1_Track? = nil
}

struct Rockbox_V1alpha1_GetAlbumsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetAlbumsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var albums: [Rockbox_V1alpha1_Album] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetArtistsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetArtistsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var artists: [Rockbox_V1alpha1_Artist] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetTracksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetTracksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tracks: [Rockbox_V1alpha1_Track] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_LikeTrackRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_LikeTrackResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_LikeAlbumRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_LikeAlbumResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_UnlikeTrackRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_UnlikeTrackResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_UnlikeAlbumRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_UnlikeAlbumResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetLikedTracksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetLikedTracksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tracks: [Rockbox_V1alpha1_Track] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetLikedAlbumsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_GetLikedAlbumsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var albums: [Rockbox_V1alpha1_Album] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_ScanLibraryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _path: String? = nil
}

struct Rockbox_V1alpha1_ScanLibraryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_SearchRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var term: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Rockbox_V1alpha1_SearchResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tracks: [Rockbox_V1alpha1_Track] = []

  var albums: [Rockbox_V1alpha1_Album] = []

  var artists: [Rockbox_V1alpha1_Artist] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rockbox.v1alpha1"

extension Rockbox_V1alpha1_Track: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Track"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}path\0\u{1}title\0\u{1}artist\0\u{1}album\0\u{3}album_artist\0\u{1}bitrate\0\u{1}composer\0\u{3}disc_number\0\u{1}filesize\0\u{1}frequency\0\u{1}length\0\u{3}track_number\0\u{1}year\0\u{3}year_string\0\u{1}genre\0\u{1}md5\0\u{3}album_art\0\u{3}artist_id\0\u{3}album_id\0\u{3}genre_id\0\u{3}created_at\0\u{3}updated_at\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _path: String = String()
    var _title: String = String()
    var _artist: String = String()
    var _album: String = String()
    var _albumArtist: String = String()
    var _bitrate: UInt32 = 0
    var _composer: String = String()
    var _discNumber: UInt32 = 0
    var _filesize: UInt32 = 0
    var _frequency: UInt32 = 0
    var _length: UInt32 = 0
    var _trackNumber: UInt32 = 0
    var _year: UInt32 = 0
    var _yearString: String = String()
    var _genre: String = String()
    var _md5: String = String()
    var _albumArt: String? = nil
    var _artistID: String? = nil
    var _albumID: String? = nil
    var _genreID: String? = nil
    var _createdAt: String = String()
    var _updatedAt: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _path = source._path
      _title = source._title
      _artist = source._artist
      _album = source._album
      _albumArtist = source._albumArtist
      _bitrate = source._bitrate
      _composer = source._composer
      _discNumber = source._discNumber
      _filesize = source._filesize
      _frequency = source._frequency
      _length = source._length
      _trackNumber = source._trackNumber
      _year = source._year
      _yearString = source._yearString
      _genre = source._genre
      _md5 = source._md5
      _albumArt = source._albumArt
      _artistID = source._artistID
      _albumID = source._albumID
      _genreID = source._genreID
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._artist) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._album) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._albumArtist) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._bitrate) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._composer) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._discNumber) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._filesize) }()
        case 11: try { try decoder.decodeSingularUInt32Field(value: &_storage._frequency) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._length) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._trackNumber) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._year) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._yearString) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._genre) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._md5) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._albumArt) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._artistID) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._albumID) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._genreID) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._createdAt) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._updatedAt) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 2)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 3)
      }
      if !_storage._artist.isEmpty {
        try visitor.visitSingularStringField(value: _storage._artist, fieldNumber: 4)
      }
      if !_storage._album.isEmpty {
        try visitor.visitSingularStringField(value: _storage._album, fieldNumber: 5)
      }
      if !_storage._albumArtist.isEmpty {
        try visitor.visitSingularStringField(value: _storage._albumArtist, fieldNumber: 6)
      }
      if _storage._bitrate != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._bitrate, fieldNumber: 7)
      }
      if !_storage._composer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._composer, fieldNumber: 8)
      }
      if _storage._discNumber != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._discNumber, fieldNumber: 9)
      }
      if _storage._filesize != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._filesize, fieldNumber: 10)
      }
      if _storage._frequency != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._frequency, fieldNumber: 11)
      }
      if _storage._length != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._length, fieldNumber: 12)
      }
      if _storage._trackNumber != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._trackNumber, fieldNumber: 13)
      }
      if _storage._year != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._year, fieldNumber: 14)
      }
      if !_storage._yearString.isEmpty {
        try visitor.visitSingularStringField(value: _storage._yearString, fieldNumber: 15)
      }
      if !_storage._genre.isEmpty {
        try visitor.visitSingularStringField(value: _storage._genre, fieldNumber: 16)
      }
      if !_storage._md5.isEmpty {
        try visitor.visitSingularStringField(value: _storage._md5, fieldNumber: 17)
      }
      try { if let v = _storage._albumArt {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._artistID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._albumID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._genreID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 21)
      } }()
      if !_storage._createdAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdAt, fieldNumber: 22)
      }
      if !_storage._updatedAt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updatedAt, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_Track, rhs: Rockbox_V1alpha1_Track) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._artist != rhs_storage._artist {return false}
        if _storage._album != rhs_storage._album {return false}
        if _storage._albumArtist != rhs_storage._albumArtist {return false}
        if _storage._bitrate != rhs_storage._bitrate {return false}
        if _storage._composer != rhs_storage._composer {return false}
        if _storage._discNumber != rhs_storage._discNumber {return false}
        if _storage._filesize != rhs_storage._filesize {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._length != rhs_storage._length {return false}
        if _storage._trackNumber != rhs_storage._trackNumber {return false}
        if _storage._year != rhs_storage._year {return false}
        if _storage._yearString != rhs_storage._yearString {return false}
        if _storage._genre != rhs_storage._genre {return false}
        if _storage._md5 != rhs_storage._md5 {return false}
        if _storage._albumArt != rhs_storage._albumArt {return false}
        if _storage._artistID != rhs_storage._artistID {return false}
        if _storage._albumID != rhs_storage._albumID {return false}
        if _storage._genreID != rhs_storage._genreID {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_Artist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Artist"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}bio\0\u{1}image\0\u{1}albums\0\u{1}tracks\0\u{1}genres\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._bio) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._image) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.albums) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._genres) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._bio {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.albums.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.albums, fieldNumber: 5)
    }
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 6)
    }
    try { if let v = self._genres {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_Artist, rhs: Rockbox_V1alpha1_Artist) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._bio != rhs._bio {return false}
    if lhs._image != rhs._image {return false}
    if lhs.albums != rhs.albums {return false}
    if lhs.tracks != rhs.tracks {return false}
    if lhs._genres != rhs._genres {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_Album: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Album"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}title\0\u{1}artist\0\u{1}year\0\u{3}year_string\0\u{3}album_art\0\u{1}md5\0\u{3}artist_id\0\u{1}label\0\u{3}copyright_message\0\u{1}tracks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.artist) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.year) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.yearString) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._albumArt) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.md5) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.artistID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._copyrightMessage) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.artist.isEmpty {
      try visitor.visitSingularStringField(value: self.artist, fieldNumber: 3)
    }
    if self.year != 0 {
      try visitor.visitSingularUInt32Field(value: self.year, fieldNumber: 4)
    }
    if !self.yearString.isEmpty {
      try visitor.visitSingularStringField(value: self.yearString, fieldNumber: 5)
    }
    try { if let v = self._albumArt {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    if !self.md5.isEmpty {
      try visitor.visitSingularStringField(value: self.md5, fieldNumber: 7)
    }
    if !self.artistID.isEmpty {
      try visitor.visitSingularStringField(value: self.artistID, fieldNumber: 8)
    }
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._copyrightMessage {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_Album, rhs: Rockbox_V1alpha1_Album) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.title != rhs.title {return false}
    if lhs.artist != rhs.artist {return false}
    if lhs.year != rhs.year {return false}
    if lhs.yearString != rhs.yearString {return false}
    if lhs._albumArt != rhs._albumArt {return false}
    if lhs.md5 != rhs.md5 {return false}
    if lhs.artistID != rhs.artistID {return false}
    if lhs._label != rhs._label {return false}
    if lhs._copyrightMessage != rhs._copyrightMessage {return false}
    if lhs.tracks != rhs.tracks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetAlbumRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAlbumRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetAlbumRequest, rhs: Rockbox_V1alpha1_GetAlbumRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetAlbumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAlbumResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}album\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._album) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._album {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetAlbumResponse, rhs: Rockbox_V1alpha1_GetAlbumResponse) -> Bool {
    if lhs._album != rhs._album {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetArtistRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetArtistRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetArtistRequest, rhs: Rockbox_V1alpha1_GetArtistRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetArtistResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetArtistResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}artist\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._artist) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._artist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetArtistResponse, rhs: Rockbox_V1alpha1_GetArtistResponse) -> Bool {
    if lhs._artist != rhs._artist {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTrackRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetTrackRequest, rhs: Rockbox_V1alpha1_GetTrackRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetTrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTrackResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}track\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._track) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._track {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetTrackResponse, rhs: Rockbox_V1alpha1_GetTrackResponse) -> Bool {
    if lhs._track != rhs._track {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetAlbumsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAlbumsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetAlbumsRequest, rhs: Rockbox_V1alpha1_GetAlbumsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetAlbumsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAlbumsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}albums\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.albums) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.albums.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.albums, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetAlbumsResponse, rhs: Rockbox_V1alpha1_GetAlbumsResponse) -> Bool {
    if lhs.albums != rhs.albums {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetArtistsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetArtistsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetArtistsRequest, rhs: Rockbox_V1alpha1_GetArtistsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetArtistsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetArtistsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}artists\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.artists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artists, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetArtistsResponse, rhs: Rockbox_V1alpha1_GetArtistsResponse) -> Bool {
    if lhs.artists != rhs.artists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTracksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetTracksRequest, rhs: Rockbox_V1alpha1_GetTracksRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetTracksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTracksResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tracks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetTracksResponse, rhs: Rockbox_V1alpha1_GetTracksResponse) -> Bool {
    if lhs.tracks != rhs.tracks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_LikeTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LikeTrackRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_LikeTrackRequest, rhs: Rockbox_V1alpha1_LikeTrackRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_LikeTrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LikeTrackResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_LikeTrackResponse, rhs: Rockbox_V1alpha1_LikeTrackResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_LikeAlbumRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LikeAlbumRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_LikeAlbumRequest, rhs: Rockbox_V1alpha1_LikeAlbumRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_LikeAlbumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LikeAlbumResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_LikeAlbumResponse, rhs: Rockbox_V1alpha1_LikeAlbumResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_UnlikeTrackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlikeTrackRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_UnlikeTrackRequest, rhs: Rockbox_V1alpha1_UnlikeTrackRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_UnlikeTrackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlikeTrackResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_UnlikeTrackResponse, rhs: Rockbox_V1alpha1_UnlikeTrackResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_UnlikeAlbumRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlikeAlbumRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_UnlikeAlbumRequest, rhs: Rockbox_V1alpha1_UnlikeAlbumRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_UnlikeAlbumResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnlikeAlbumResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_UnlikeAlbumResponse, rhs: Rockbox_V1alpha1_UnlikeAlbumResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetLikedTracksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLikedTracksRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetLikedTracksRequest, rhs: Rockbox_V1alpha1_GetLikedTracksRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetLikedTracksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLikedTracksResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tracks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetLikedTracksResponse, rhs: Rockbox_V1alpha1_GetLikedTracksResponse) -> Bool {
    if lhs.tracks != rhs.tracks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetLikedAlbumsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLikedAlbumsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetLikedAlbumsRequest, rhs: Rockbox_V1alpha1_GetLikedAlbumsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_GetLikedAlbumsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetLikedAlbumsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}albums\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.albums) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.albums.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.albums, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_GetLikedAlbumsResponse, rhs: Rockbox_V1alpha1_GetLikedAlbumsResponse) -> Bool {
    if lhs.albums != rhs.albums {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_ScanLibraryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScanLibraryRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}path\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_ScanLibraryRequest, rhs: Rockbox_V1alpha1_ScanLibraryRequest) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_ScanLibraryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScanLibraryResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_ScanLibraryResponse, rhs: Rockbox_V1alpha1_ScanLibraryResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_SearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}term\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.term) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.term.isEmpty {
      try visitor.visitSingularStringField(value: self.term, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_SearchRequest, rhs: Rockbox_V1alpha1_SearchRequest) -> Bool {
    if lhs.term != rhs.term {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rockbox_V1alpha1_SearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SearchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tracks\0\u{1}albums\0\u{1}artists\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tracks) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.albums) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.artists) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tracks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tracks, fieldNumber: 1)
    }
    if !self.albums.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.albums, fieldNumber: 2)
    }
    if !self.artists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artists, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rockbox_V1alpha1_SearchResponse, rhs: Rockbox_V1alpha1_SearchResponse) -> Bool {
    if lhs.tracks != rhs.tracks {return false}
    if lhs.albums != rhs.albums {return false}
    if lhs.artists != rhs.artists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
